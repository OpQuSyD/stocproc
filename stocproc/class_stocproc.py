# -*- coding: utf8 -*-
from __future__ import print_function, division

import numpy as np
from scipy.interpolate import InterpolatedUnivariateSpline
from scipy.integrate import quad
#from .class_stocproc_kle import StocProc
from .stocproc import solve_hom_fredholm
from .stocproc import get_simpson_weights_times
from . import method_kle
from . import method_fft
from . import stocproc_c
import logging

log = logging.getLogger(__name__)

class ComplexInterpolatedUnivariateSpline(object):
    r"""
    Univariant spline interpolator from scpi.interpolate in a convenient fashion to
    interpolate real and imaginary parts of complex data 
    """
    def __init__(self, x, y, k=2):
        self.re_spline = InterpolatedUnivariateSpline(x, np.real(y))
        self.im_spline = InterpolatedUnivariateSpline(x, np.imag(y))
        
    def __call__(self, t):
        return self.re_spline(t) + 1j*self.im_spline(t)
    
def complex_quad(func, a, b, **kw_args):
    func_re = lambda t: np.real(func(t))
    func_im = lambda t: np.imag(func(t))
    I_re = quad(func_re, a, b, **kw_args)[0]
    I_im = quad(func_im, a, b, **kw_args)[0]
    
    return I_re + 1j*I_im    

class _absStocProc(object):
    r"""
    Abstract base class to stochastic process interface
    
    general work flow:
        - Specify the time axis of interest [0, t_max] and it resolution (number of grid points), :math:`t_i = i \frac{t_max}{N_t-1}.  
        - To evaluate the stochastic process at these points, a mapping from :math:`N_z` normal distributed 
          random complex numbers with :math:`\langle y_i y_j^\ast \rangle = 2 \delta_{ij}`
          to the stochastic process :math:`z_{t_i}` is needed and depends on the implemented method (:py:func:`_calc_z').
        - A new process should be generated by calling :py:func:`new_process'.
        - When the __call__ method is invoked the results will be interpolated between the :math:`z_t_i`.
        
      
    """
    def __init__(self, t_max, num_grid_points, seed=None, verbose=1, k=3):
        r"""
            :param t_max: specify time axis as [0, t_max]
            :param num_grid_points: number of equidistant times on that axis
            :param seed: if not ``None`` set seed to ``seed``
            :param verbose: 0: no output, 1: informational output, 2: (eventually some) debug info
            :param k: polynomial degree used for spline interpolation  
        """
        self._verbose = verbose
        self.t_max = t_max
        self.num_grid_points = num_grid_points
        self.t = np.linspace(0, t_max, num_grid_points)
        self._z = None
        self._interpolator = None
        self._k = k
        if seed is not None:
            np.random.seed(seed)
        self._one_over_sqrt_2 = 1/np.sqrt(2)

    def __call__(self, t):
        r"""
        :param t: time to evaluate the stochastic process as, float of array of floats
        evaluates the stochastic process via spline interpolation between the discrete process 
        """
        if self._z is None:
            raise RuntimeError("StocProc_FFT has NO random data, call 'new_process' to generate a new random process")
        if self._interpolator is None:
            if self._verbose > 1:
                print("setup interpolator ...")
            self._interpolator = ComplexInterpolatedUnivariateSpline(self.t, self._z, k=self._k)
            if self._verbose > 1:
                print("done!")
                
        return self._interpolator(t)
    
    def _calc_z(self, y):
        r"""
        maps the normal distributed complex valued random variables y to the stochastic process
        
        :return: the stochastic process, array of complex numbers 
        """
        pass
    
    def get_num_y(self):
        r"""
        :return: number of complex random variables needed to calculate the stochastic process 
        """
        pass        
    
    def get_time(self):
        r"""
        :return: time axis
        """
        return self.t
    
    def get_z(self):
        r"""
        use :py:func:`new_process` to generate a new process
        :return: the current process 
        """
        return self._z
    
    def new_process(self, y=None, seed=None):
        r"""
        generate a new process by evaluating :py:func:`_calc_z'
        
        When ``y`` is given use these random numbers as input for :py:func:`_calc_z`
        otherwise generate a new set of random numbers.
        
        :param y: independent normal distributed complex valued random variables with :math:`\sig_{ij}^2 = \langle y_i y_j^\ast \rangle = 2 \delta_{ij}
        :param seed: if not ``None`` set seed to ``seed`` before generating samples 
        """
        self._interpolator = None
        if seed != None:
            if self._verbose > 0:
                print("use seed", seed)
            np.random.seed(seed)
        if y is None:
            #random complex normal samples
            if self._verbose > 1:
                print("generate samples ...")
            y = np.random.normal(scale=self._one_over_sqrt_2, size = 2*self.get_num_y()).view(np.complex)
            if self._verbose > 1:
                print("done")        

        self._z = self._calc_z(y)               

class StocProc_KLE(_absStocProc):
    r"""
    class to simulate stochastic processes using KLE method
        - Solve fredholm equation on grid with ``ng_fredholm nodes`` (trapezoidal_weights).
          If case ``ng_fredholm`` is ``None`` set ``ng_fredholm = num_grid_points``. In general it should
          hold ``ng_fredholm < num_grid_points`` and ``num_grid_points = 10*ng_fredholm`` might be a good ratio. 
        - Calculate discrete stochastic process (using interpolation solution of fredholm equation) with num_grid_points nodes
        - invoke spline interpolator when calling 
    """
    def __init__(self, r_tau, t_max, ng_fredholm, ng_fac=4, seed=None, sig_min=1e-5, verbose=1, k=3, align_eig_vec=False):
        r"""
            :param r_tau: auto correlation function of the stochastic process
            :param t_max: specify time axis as [0, t_max]
            :param seed: if not ``None`` set seed to ``seed``
            :param sig_min: eigenvalue threshold (see KLE method to generate stochastic processes)
            :param verbose: 0: no output, 1: informational output, 2: (eventually some) debug info
            :param k: polynomial degree used for spline interpolation             
        """
        self.verbose = verbose
        self.ng_fac = ng_fac
        if ng_fac == 1:
            self.kle_interp = False
        else:
            self.kle_interp = True
            
        t, w = method_kle.get_simpson_weights_times(t_max, ng_fredholm)
        self._one_over_sqrt_2 = 1/np.sqrt(2)
        self._r_tau = r_tau
        self._s = t
        self._num_gp = len(self._s)
        self._w = w

        r = self._calc_corr_matrix(self._s, self._r_tau)            
        # solve discrete Fredholm equation
        # eig_val = lambda
        # eig_vec = u(t)
        self._eig_val, self._eig_vec = method_kle.solve_hom_fredholm(r, w, sig_min**2, verbose=self.verbose-1)
        if align_eig_vec:
            for i in range(self._eig_vec.shape[1]):
                s = np.sum(self._eig_vec[:,i])
                phase  = np.exp(1j*np.arctan2(np.real(s), np.imag(s)))
                self._eig_vec[:,i]/= phase


        self.__calc_missing()
          
        ng_fine = self.ng_fac * (self._num_gp - 1) + 1        
        self.alpha_k = self._calc_corr_min_t_plus_t(s   = np.linspace(0, t_max, ng_fine), 
                                                    bcf = self._r_tau) 
        super().__init__(t_max=t_max, num_grid_points=ng_fine, seed=seed, verbose=verbose, k=k)
                
        self.num_y = self._num_ev
        self.verbose = verbose    
    
    @staticmethod
    def _calc_corr_min_t_plus_t(s, bcf):
        bcf_n_plus = bcf(s-s[0])
        #    [bcf(-3)    , bcf(-2)    , bcf(-1)    , bcf(0), bcf(1), bcf(2), bcf(3)]
        # == [bcf(3)^\ast, bcf(2)^\ast, bcf(1)^\ast, bcf(0), bcf(1), bcf(2), bcf(3)]        
        return np.hstack((np.conj(bcf_n_plus[-1:0:-1]), bcf_n_plus))        
    
    @staticmethod
    def _calc_corr_matrix(s, bcf):
        """calculates the matrix alpha_ij = bcf(t_i-s_j)
        
        calls bcf only for s-s_0 and reconstructs the rest
        """
        n_ = len(s)
        bcf_n = StocProc_KLE._calc_corr_min_t_plus_t(s, bcf)
        # we want
        # r = bcf(0) bcf(-1), bcf(-2)
        #     bcf(1) bcf( 0), bcf(-1)
        #     bcf(2) bcf( 1), bcf( 0)
        r = np.empty(shape=(n_,n_), dtype = np.complex128)
        for i in range(n_):
            idx = n_-1-i
            r[:,i] = bcf_n[idx:idx+n_]
        return r
        
    
        
    def __calc_missing(self):
        self._num_gp = len(self._s)
        self._sqrt_eig_val = np.sqrt(self._eig_val)
        self._num_ev = len(self._eig_val)
        self._A = self._w.reshape(self._num_gp,1) * self._eig_vec / self._sqrt_eig_val.reshape(1, self._num_ev)
    
    def _x_t_mem_save(self, kahanSum=False):
        """calculate the stochastic process (SP) for a certain class fine grids
        
        when the SP is setup with n grid points, which means we know the eigenfunctions
        for the n discrete times t_i = i/(n-1)*t_max, i = 0,1,...n-1
        with delta_t = t_max/(n-1)
        it is efficient to calculate the interpolated process
        for finer grids with delta_t_fine = delta_t/delta_t_fac
        because we only need to know the bcf on the finer grid
        """               
        return stocproc_c.z_t(delta_t_fac = self.ng_fac,
                              N1          = self._num_gp,
                              alpha_k     = self.alpha_k,
                              a_tmp       = self._a_tmp,
                              kahanSum    = kahanSum)
        
    def _x_for_initial_time_grid(self):
        r"""Get process on initial time grid
        
        Returns the value of the Stochastic Process for 
        the times given to the constructor in order to discretize the Fredholm
        equation. This is equivalent to calling :py:func:`stochastic_process_kle` with the
        same weights :math:`w_i` and time grid points :math:`s_i`.
        """
        tmp = self._Y * self._sqrt_eig_val.reshape(self._num_ev,1) 
        if self.verbose > 1:
            print("calc process via matrix prod ...")
        res = np.tensordot(tmp, self._eig_vec, axes=([0],[1])).flatten()
        if self.verbose > 1:
            print("done!")
        
        return res
    
    def _new_process(self, yi=None, seed=None):
        r"""setup new process
        
        Generates a new set of independent normal random variables :math:`Y_i`
        which correspondent to the expansion coefficients of the
        Karhunen-Loève expansion for the stochastic process
        
        .. math:: X(t) = \sum_i \sqrt{\lambda_i} Y_i u_i(t)
        
        :param seed: a seed my be given which is passed to the random number generator
        """
        if seed != None:
            np.random.seed(seed)

        if yi is None:
            if self.verbose > 1:
                print("generate samples ...")
            self._Y = np.random.normal(scale = self._one_over_sqrt_2, size=2*self._num_ev).view(np.complex).reshape(self._num_ev,1)
            if self.verbose > 1:
                print("done!")
        else:
            self._Y = yi.reshape(self._num_ev,1)

        self._a_tmp = np.tensordot(self._Y[:,0], self._A, axes=([0],[1]))            

    def _calc_z(self, y):
        r"""
        uses the underlaying stocproc class to generate the process (see :py:class:`StocProc` for details) 
        """
        self._new_process(y)
        
        if self.kle_interp:
            #return self.stocproc.x_t_array(np.linspace(0, self.t_max, self.num_grid_points))
            return self._x_t_mem_save(kahanSum=True)
        else:
            return self._x_for_initial_time_grid()
        
    def get_num_y(self):
        return self.num_y
    
    
    
class StocProc_KLE_tol(StocProc_KLE):
    r"""
        same as StocProc_KLE except that ng_fredholm is determined from given tolerance
    """
    
    def __init__(self, tol, **kwargs):
        self.tol = tol
        self._auto_grid_points(**kwargs)
        
    def _init_StocProc_KLE_and_get_error(self, ng, **kwargs):
        super().__init__(ng_fredholm=ng, **kwargs)
            
        ng_fine = self.ng_fac*(ng-1)+1
        #t_fine = np.linspace(0, self.t_max, ng_fine)
        

        u_i_all_t =  stocproc_c.eig_func_all_interp(delta_t_fac = self.ng_fac,
                                                    time_axis   = self._s,
                                                    alpha_k     = self.alpha_k, 
                                                    weights     = self._w,
                                                    eigen_val   = self._eig_val,
                                                    eigen_vec   = self._eig_vec)    

        u_i_all_ast_s = np.conj(u_i_all_t)                  #(N_gp, N_ev)
        num_ev = len(self._eig_val)       
        tmp = self._eig_val.reshape(1, num_ev) * u_i_all_t  #(N_gp, N_ev)  
        recs_bcf = np.tensordot(tmp, u_i_all_ast_s, axes=([1],[1]))
        
        refc_bcf = np.empty(shape=(ng_fine,ng_fine), dtype = np.complex128)
        for i in range(ng_fine):
            idx = ng_fine-1-i
            refc_bcf[:,i] = self.alpha_k[idx:idx+ng_fine]
        
        err = np.max(np.abs(recs_bcf-refc_bcf)/np.abs(refc_bcf))
        return err
        
    
    def _auto_grid_points(self, **kwargs): 
        err = np.inf
        c = 2
        #exponential increase to get below error threshold
        while err > self.tol:
            c *= 2
            ng = 2*c + 1
            print("ng {}".format(ng), end='', flush=True)
            err = self._init_StocProc_KLE_and_get_error(ng, **kwargs)
            print(" -> err {:.3g}".format(err))
                       
        c_low = c // 2
        c_high = c
         
        while (c_high - c_low) > 1:            
            c = (c_low + c_high) // 2
            ng = 2*c + 1
            print("ng {}".format(ng), end='', flush=True)
            err = self._init_StocProc_KLE_and_get_error(ng, **kwargs)
            print(" -> err {:.3g}".format(err))
            if err > self.tol:
                c_low = c
            else:
                c_high = c         
        

class StocProc_FFT(_absStocProc):
    r"""
        Simulate Stochastic Process using FFT method 
    """
    def __init__(self, spectral_density, t_max, num_grid_points, seed=None, verbose=0, k=3, omega_min=0):
        super().__init__(t_max           = t_max, 
                         num_grid_points = num_grid_points, 
                         seed            = seed, 
                         verbose         = verbose,
                         k               = k)
        
        self.n_dft           = num_grid_points * 2 - 1
        delta_t              = t_max / (num_grid_points-1)
        self.delta_omega     = 2 * np.pi / (delta_t * self.n_dft)
        self.omega_min = omega_min
        t = np.arange(num_grid_points) * delta_t
        self.omega_min_correction = np.exp(-1j * self.omega_min * t)
        
          
        #omega axis
        omega = self.delta_omega*np.arange(self.n_dft)
        #reshape for multiplication with matrix xi
        self.sqrt_spectral_density_over_pi_times_sqrt_delta_omega = np.sqrt(spectral_density(omega + self.omega_min)) * np.sqrt(self.delta_omega / np.pi) 
        
        if self._verbose > 0:
            print("stoc proc fft, spectral density sampling information:")
            print("  t_max      :", (t_max))
            print("  ng         :", (num_grid_points))
            
            print("  omega_min  :", (self.omega_min))
            print("  omega_max  :", (self.omega_min + self.delta_omega * self.n_dft))
            print("  delta_omega:", (self.delta_omega))
            
    def _calc_z(self, y):
        weighted_integrand = self.sqrt_spectral_density_over_pi_times_sqrt_delta_omega * y 
        #compute integral using fft routine
        if self._verbose > 1:
            print("calc process via fft ...")
        z = np.fft.fft(weighted_integrand)[0:self.num_grid_points] * self.omega_min_correction
        if self._verbose > 1:
            print("done")
        return z

    def get_num_y(self):
        return self.n_dft
    
    
class StocProc_FFT_tol(_absStocProc):
    r"""
        Simulate Stochastic Process using FFT method 
    """
    def __init__(self, spectral_density, t_max, bcf_ref, intgr_tol=1e-3, intpl_tol=1e-3, 
                 seed=None, verbose=0, k=3, negative_frequencies=False, method='simps'):
        if not negative_frequencies: 
            log.debug("non neg freq only")
            # assume the spectral_density is 0 for w<0 
            # and decays fast for large w
            b = method_fft.find_integral_boundary(integrand = spectral_density, 
                                                  tol       = intgr_tol**2, 
                                                  ref_val   = 1, 
                                                  max_val   = 1e6, 
                                                  x0        = 1)
            log.debug("upper int bound b {:.3e}".format(b))
            b, N, dx, dt = method_fft.calc_ab_N_dx_dt(integrand = spectral_density, 
                                                      intgr_tol = intgr_tol, 
                                                      intpl_tol = intpl_tol, 
                                                      tmax      = t_max, 
                                                      a         = 0, 
                                                      b         = b, 
                                                      ft_ref    = lambda tau:bcf_ref(tau)*np.pi, 
                                                      N_max     = 2**20, 
                                                      method    = method)
            log.debug("required tol result in N {}".format(N))
            a = 0
        else:
            # assume the spectral_density is non zero also for w<0 
            # but decays fast for large |w|
            b = method_fft.find_integral_boundary(integrand = spectral_density, 
                                                  tol       = intgr_tol**2, 
                                                  ref_val   = 1, 
                                                  max_val   = 1e6, 
                                                  x0        = 1)
            a = method_fft.find_integral_boundary(integrand = spectral_density, 
                                                  tol       = intgr_tol**2, 
                                                  ref_val   = -1, 
                                                  max_val   = 1e6, 
                                                  x0        = -1)            
            b_minus_a, N, dx, dt = method_fft.calc_ab_N_dx_dt(integrand = spectral_density, 
                                                              intgr_tol = intgr_tol, 
                                                              intpl_tol = intpl_tol, 
                                                              tmax      = t_max, 
                                                              a         = a, 
                                                              b         = b, 
                                                              ft_ref    = lambda tau:bcf_ref(tau)*np.pi, 
                                                              N_max     = 2**20, 
                                                              method    = method)
            b = b*b_minus_a/(b-a)
            a = b-b_minus_a
        
        
        num_grid_points = int(np.ceil(t_max/dt))+1
        t_max = (num_grid_points-1)*dt
        
        super().__init__(t_max           = t_max, 
                         num_grid_points = num_grid_points, 
                         seed            = seed, 
                         verbose         = verbose,
                         k               = k)
        
        self.n_dft           = N
        omega = dx*np.arange(self.n_dft)
        if method == 'simps':
            self.yl = spectral_density(omega + a) * dx / np.pi
            self.yl = method_fft.get_fourier_integral_simps_weighted_values(self.yl)
            self.yl = np.sqrt(self.yl)
            self.omega_min_correction = np.exp(-1j*a*self.t)   #self.t is from the parent class
        elif method == 'midp':
            self.yl = spectral_density(omega + a + dx/2) * dx / np.pi
            self.yl = np.sqrt(self.yl)
            self.omega_min_correction = np.exp(-1j*(a+dx/2)*self.t)   #self.t is from the parent class
        else:
            raise ValueError("unknown method '{}'".format(method))
            
            
    def _calc_z(self, y): 
        z = np.fft.fft(self.yl * y)[0:self.num_grid_points] * self.omega_min_correction
        return z

    def get_num_y(self):
        return self.n_dft        