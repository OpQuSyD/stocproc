"""
Stochastic Process Generators
=============================

Karhunen-Loève expansion
------------------------

This method samples stochastic processes using Karhunen-Loève expansion and
is implemented in the class :doc:`StocProc_KLE_tol </StocProc_KLE>`.

Setting up the class involves solving an eigenvalue problem which grows with
the time interval the process is simulated on. Further generating a new process
involves a multiplication with that matrix, therefore it scales quadratically with the
time interval. Nonetheless it turns out that this method requires less random numbers
than the Fast-Fourier method.


Fast-Fourier method
-------------------
simulate stochastic processes using Fast-Fourier method method :py:func:`stocproc.StocProc_FFT_tol`

Setting up this class is quite efficient as it only calculates values of the
associated spectral density. The number scales linear with the time interval of interest. However to achieve
sufficient accuracy many of these values are required. As the generation of a new process is based on
a Fast-Fouried-Transform over these values, this part is comparably lengthy.
"""
import abc
import numpy as np
import time

from . import method_kle
from . import method_fft
from . import stocproc_c
from .tools import ComplexInterpolatedUnivariateSpline

import logging
log = logging.getLogger(__name__)

class _absStocProc(abc.ABC):
    r"""
    Abstract base class to stochastic process interface
    
    general work flow:
        - Specify the time axis of interest [0, t_max] and it resolution (number of grid points), :math:`t_i = i \frac{t_max}{N_t-1}.  
        - To evaluate the stochastic process at these points, a mapping from :math:`N_z` normal distributed 
          random complex numbers with :math:`\langle y_i y_j^\ast \rangle = 2 \delta_{ij}`
          to the stochastic process :math:`z_{t_i}` is needed and depends on the implemented method (:py:func:`_calc_z').
        - A new process should be generated by calling :py:func:`new_process'.
        - When the __call__ method is invoked the results will be interpolated between the :math:`z_t_i`.
        
      
    """
    def __init__(self, t_max, num_grid_points, seed=None):
        r"""
            :param t_max: specify time axis as [0, t_max]
            :param num_grid_points: number of equidistant times on that axis
            :param seed: if not ``None`` set seed to ``seed``
            :param verbose: 0: no output, 1: informational output, 2: (eventually some) debug info
        """
        self.t_max = t_max
        self.num_grid_points = num_grid_points
        self.t = np.linspace(0, t_max, num_grid_points)
        self._z = None
        self._interpolator = None
        self._seed = seed
        if seed is not None:
            np.random.seed(seed)
        self._one_over_sqrt_2 = 1/np.sqrt(2)
        self._proc_cnt = 0
        log.debug("init StocProc with t_max {} and {} grid points".format(t_max, num_grid_points))

    def __call__(self, t=None):
        r"""
        :param t: time to evaluate the stochastic process as, float of array of floats
        evaluates the stochastic process via spline interpolation between the discrete process 
        """
        if self._z is None:
            raise RuntimeError("StocProc_FFT has NO random data, call 'new_process' to generate a new random process")

        if t is None:
            return self._z
        else:
            if self._interpolator is None:
                t0 = time.time()
                self._interpolator = ComplexInterpolatedUnivariateSpline(self.t, self._z, k=3)
                log.debug("created interpolator [{:.2e}s]".format(time.time() - t0))
            return self._interpolator(t)

    @abc.abstractmethod
    def _calc_z(self, y):
        r"""
        maps the normal distributed complex valued random variables y to the stochastic process
        
        :return: the stochastic process, array of complex numbers 
        """
        pass

    @abc.abstractmethod
    def get_num_y(self):
        r"""
        :return: number of complex random variables needed to calculate the stochastic process 
        """
        pass        
    
    def get_time(self):
        r"""
        :return: time axis
        """
        return self.t
    
    def get_z(self):
        r"""
        use :py:func:`new_process` to generate a new process
        :return: the current process 
        """
        return self._z
    
    def new_process(self, y=None, seed=None):
        r"""
        generate a new process by evaluating :py:func:`_calc_z'
        
        When ``y`` is given use these random numbers as input for :py:func:`_calc_z`
        otherwise generate a new set of random numbers.
        
        :param y: independent normal distributed complex valued random variables with :math:`\sig_{ij}^2 = \langle y_i y_j^\ast \rangle = 2 \delta_{ij}
        :param seed: if not ``None`` set seed to ``seed`` before generating samples 
        """
        t0 = time.time()
        self._interpolator = None
        self._proc_cnt += 1
        if seed != None:
            log.info("use fixed seed ({})for new process".format(seed))
            np.random.seed(seed)
        if y is None:
            #random complex normal samples
            y = np.random.normal(scale=self._one_over_sqrt_2, size = 2*self.get_num_y()).view(np.complex)
        self._z = self._calc_z(y)
        log.debug("proc_cnt:{} new process generated [{:.2e}s]".format(self._proc_cnt, time.time() - t0))


class StocProc_KLE(_absStocProc):
    r"""
        A class to simulate stochastic processes using Karhunen-Loève expansion (KLE) method.
        The idea is that any stochastic process can be expressed in terms of the KLE

        .. math:: Z(t) = \sum_i \sqrt{\lambda_i} Y_i u_i(t)

        where :math:`Y_i` and independent complex valued Gaussian random variables with variance one
        (:math:`\langle Y_i Y_j \rangle = \delta_{ij}`) and :math:`\lambda_i`, :math:`u_i(t)` are
        eigenvalues / eigenfunctions of the following Fredholm equation

        .. math:: \int_0^{t_\mathrm{max}} \mathrm{d}s R(t-s) u_i(s) = \lambda_i u_i(t)

        for a given positive integral kernel :math:`R(\tau)`. It turns out that the auto correlation
        :math:`\langle Z(t)Z^\ast(s) \rangle = R(t-s)` is given by that kernel.

        For the numeric implementation the integral equation will be discretized
        (see :py:func:`stocproc.method_kle.solve_hom_fredholm` for details).


        - Solve fredholm equation on grid with ``ng_fredholm nodes`` (trapezoidal_weights).
          If case ``ng_fredholm`` is ``None`` set ``ng_fredholm = num_grid_points``. In general it should
          hold ``ng_fredholm < num_grid_points`` and ``num_grid_points = 10*ng_fredholm`` might be a good ratio.
        - Calculate discrete stochastic process (using interpolation solution of fredholm equation) with num_grid_points nodes
        - invoke spline interpolator when calling

        same as StocProc_KLE except that ng_fredholm is determined from given tolerance

        bla bla

    """
    
    def __init__(self, r_tau, t_max, ng_fac=4, meth='fourpoint', tol=1e-2, diff_method='full', dm_random_samples=10**4,
        seed=None, align_eig_vec=False):
        """this is init

        :param r_tau:
        :param t_max:
        :param tol:
        :param ng_fac:
        :param seed:
        :param k:
        :param align_eig_vec:
        """

        sqrt_lambda_ui_fine = method_kle.auto_ng(corr=r_tau,
                                                 t_max=t_max,
                                                 ngfac=ng_fac,
                                                 meth=meth,
                                                 tol=tol,
                                                 diff_method=diff_method,
                                                 dm_random_samples=dm_random_samples)

        # inplace alignment such that re(ui(0)) >= 0 and im(ui(0)) = 0
        if align_eig_vec:
            method_kle.align_eig_vec(sqrt_lambda_ui_fine)

        state = sqrt_lambda_ui_fine, t_max, seed
        self.__setstate__(state)
        self.key = r_tau, t_max, tol

    def __getstate__(self):
        return self.sqrt_lambda_ui_fine, self.t_max, self._seed

    def __setstate__(self, state):
        sqrt_lambda_ui_fine, t_max, seed = state
        num_ev, ng = sqrt_lambda_ui_fine.shape
        super().__init__(t_max           = t_max,
                         num_grid_points = ng,
                         seed            = seed)
        self.num_ev = num_ev
        self.sqrt_lambda_ui_fine = sqrt_lambda_ui_fine

    def _calc_z(self, y):
        return np.tensordot(y, self.sqrt_lambda_ui_fine, axes=([0], [0])).flatten()

    def get_num_y(self):
        return self.num_ev


class StocProc_FFT(_absStocProc):
    r"""
        Simulate Stochastic Process using FFT method 
    """
    def __init__(self, spectral_density, t_max, bcf_ref, intgr_tol=1e-2, intpl_tol=1e-2,
                 seed=None, negative_frequencies=False):
        if not negative_frequencies: 
            log.info("non neg freq only")
            # assume the spectral_density is 0 for w<0 
            # and decays fast for large w
            b = method_fft.find_integral_boundary(integrand = spectral_density, 
                                                  tol       = intgr_tol**2,
                                                  ref_val   = 1, 
                                                  max_val   = 1e6, 
                                                  x0        = 1)
            log.info("upper int bound b {:.3e}".format(b))
            a, b, N, dx, dt = method_fft.calc_ab_N_dx_dt(integrand = spectral_density,
                                                         intgr_tol = intgr_tol,
                                                         intpl_tol = intpl_tol,
                                                         t_max     = t_max,
                                                         a         = 0,
                                                         b         = b,
                                                         ft_ref    = lambda tau:bcf_ref(tau)*np.pi,
                                                         opt_b_only= True,
                                                         N_max     = 2**24)
            log.info("required tol results in N {}".format(N))
        else:
            log.info("use neg freq")
            # assume the spectral_density is non zero also for w<0 
            # but decays fast for large |w|
            b = method_fft.find_integral_boundary(integrand = spectral_density, 
                                                  tol       = intgr_tol**2,
                                                  ref_val   = 1, 
                                                  max_val   = 1e6, 
                                                  x0        = 1)
            a = method_fft.find_integral_boundary(integrand = spectral_density, 
                                                  tol       = intgr_tol**2,
                                                  ref_val   = -1, 
                                                  max_val   = 1e6, 
                                                  x0        = -1)            
            a, b, N, dx, dt = method_fft.calc_ab_N_dx_dt(integrand = spectral_density,
                                                              intgr_tol = intgr_tol, 
                                                              intpl_tol = intpl_tol, 
                                                              t_max     = t_max,
                                                              a         = a,
                                                              b         = b,
                                                              ft_ref    = lambda tau:bcf_ref(tau)*np.pi,
                                                              opt_b_only= False,
                                                              N_max     = 2**24)
            log.info("required tol result in N {}".format(N))

        assert abs(2*np.pi - N*dx*dt) < 1e-12
        num_grid_points = int(np.ceil(t_max/dt))+1
        t_max = (num_grid_points-1)*dt
        
        super().__init__(t_max           = t_max, 
                         num_grid_points = num_grid_points, 
                         seed            = seed)
        
        omega = dx*np.arange(N)
        self.yl = spectral_density(omega + a + dx/2) * dx / np.pi
        self.yl = np.sqrt(self.yl)
        self.omega_min_correction = np.exp(-1j*(a+dx/2)*self.t)   #self.t is from the parent class
        self.key = bcf_ref, t_max, intgr_tol, intpl_tol

    def __getstate__(self):
        return self.yl, self.num_grid_points, self.omega_min_correction, self.t_max, self._seed

    def __setstate__(self, state):
        self.yl, num_grid_points, self.omega_min_correction, t_max, seed = state
        super().__init__(t_max           = t_max,
                         num_grid_points = num_grid_points,
                         seed            = seed)
            
    def _calc_z(self, y): 
        z = np.fft.fft(self.yl * y)[0:self.num_grid_points] * self.omega_min_correction
        return z

    def get_num_y(self):
        return len(self.yl)