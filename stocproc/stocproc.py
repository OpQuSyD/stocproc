"""
Stochastic Process Generators
=============================


Karhunen-Loève expansion
------------------------

.. toctree::
   :maxdepth: 2

   StocProc_KLE

This method samples stochastic processes using Karhunen-Loève expansion and
is implemented in the class :doc:`StocProc_KLE </StocProc_KLE>`.

Setting up the class involves solving an eigenvalue problem which grows with
the time interval the process is simulated on. Further generating a new process
involves a multiplication with that matrix, therefore it scales quadratically with the
time interval. Nonetheless it turns out that this method requires less random numbers
than the Fast-Fourier method.


Fast-Fourier method
-------------------

.. toctree::
   :maxdepth: 2

   StocProc_FFT

In the class :doc:`StocProc_FFT </StocProc_FFT>` a method based on Fast-Fourier transform is
used to sample stochastic processes.

Setting up this class is quite efficient as it only calculates values of the
associated spectral density. The number scales linear with the time interval of interest. However to achieve
sufficient accuracy many of these values are required. As the generation of a new process is based on
a Fast-Fouried-Transform over these values, this part is comparably lengthy.
"""
import abc
import numpy as np
import time

from . import method_kle
from . import method_fft
from . import stocproc_c
from .tools import ComplexInterpolatedUnivariateSpline

import logging
log = logging.getLogger(__name__)

class _absStocProc(abc.ABC):
    r"""
    Abstract base class to stochastic process interface
    
    general work flow:
        - Specify the time axis of interest [0, t_max] and it resolution (number of grid points), :math:`t_i = i \frac{t_max}{N_t-1}.  
        - To evaluate the stochastic process at these points, a mapping from :math:`N_z` normal distributed 
          random complex numbers with :math:`\langle y_i y_j^\ast \rangle = 2 \delta_{ij}`
          to the stochastic process :math:`z_{t_i}` is needed and depends on the implemented method (:py:func:`_calc_z').
        - A new process should be generated by calling :py:func:`new_process'.
        - When the __call__ method is invoked the results will be interpolated between the :math:`z_t_i`.
        
      
    """
    def __init__(self, t_max=None, num_grid_points=None, seed=None, t_axis=None):
        r"""
            :param t_max: specify time axis as [0, t_max], if None, the times must be explicitly
                given by t_axis
            :param num_grid_points: number of equidistant times on that axis
            :param seed: if not ``None`` set seed to ``seed``
            :param t_axis: an explicit definition of times t_k (may be non equidistant)
        """
        if t_max is not None:
            self.t = np.linspace(0, t_max, num_grid_points)
        else:
            self.t = t_axis

        self.t_max = self.t[-1]
        self.num_grid_points = len(self.t)

        self._z = None
        self._interpolator = None
        self._seed = seed
        if seed is not None:
            np.random.seed(seed)
        self._one_over_sqrt_2 = 1/np.sqrt(2)
        self._proc_cnt = 0
        log.debug("init StocProc with t_max {} and {} grid points".format(t_max, num_grid_points))

    def __call__(self, t=None):
        r"""evaluates the stochastic process via spline interpolation of the discrete process :math:`z_k`

        :param t: time to evaluate the stochastic process at, float of array of floats, if t is None
            return the discrete process :math:`z_k` which corresponds to the times :math:`t_k` given by the
            integration weights method
        :return: a single complex value or a complex array of the shape of t that holds the values of
            stochastic process at times t
        """
        if self._z is None:
            raise RuntimeError("StocProc_FFT has NO random data, call 'new_process' to generate a new random process")

        if t is None:
            return self._z
        else:
            if self._interpolator is None:
                t0 = time.time()
                self._interpolator = ComplexInterpolatedUnivariateSpline(self.t, self._z, k=3)
                log.debug("created interpolator [{:.2e}s]".format(time.time() - t0))
            return self._interpolator(t)

    @abc.abstractmethod
    def calc_z(self, y):
        r"""
        maps the normal distributed complex valued random variables y to the stochastic process
        
        :return: the stochastic process, array of complex numbers 
        """
        pass

    @abc.abstractmethod
    def get_num_y(self):
        r"""
        :return: number of complex random variables needed to calculate the stochastic process 
        """
        pass        
    
    def get_time(self):
        r"""Returns the time :math:`t_k` corresponding to the values :math:`z_k`

        These times are determined by the integration weights method.
        """
        return self.t
    
    def get_z(self):
        r"""Returns the discrete process :math:`z_k`."""
        return self._z
    
    def new_process(self, y=None, seed=None):
        r"""generate a new process by evaluating :py:func:`calc_z` with new random variables :math:`Y_i`

        :param y: independent normal distributed complex valued random variables with :math:`\sigma_{ij}^2 = \langle y_i y_j^\ast \rangle = 2 \delta_{ij}`
        :param seed: if not None set seed to seed before generating samples
        
        When y is given use these random numbers as input for :py:func:`calc_z`
        otherwise generate a new set of random numbers.
        """
        t0 = time.time()
        self._interpolator = None
        self._proc_cnt += 1
        if seed != None:
            log.info("use fixed seed ({})for new process".format(seed))
            np.random.seed(seed)
        if y is None:
            #random complex normal samples
            y = np.random.normal(scale=self._one_over_sqrt_2, size = 2*self.get_num_y()).view(np.complex)
        self._z = self.calc_z(y)
        log.debug("proc_cnt:{} new process generated [{:.2e}s]".format(self._proc_cnt, time.time() - t0))


class StocProc_KLE(_absStocProc):
    r"""
        A class to simulate stochastic processes using Karhunen-Loève expansion (KLE) method.
        The idea is that any stochastic process can be expressed in terms of the KLE

        .. math:: Z(t) = \sum_i \sqrt{\lambda_i} Y_i u_i(t)

        where :math:`Y_i` and independent complex valued Gaussian random variables with variance one
        (:math:`\langle Y_i Y_j \rangle = \delta_{ij}`) and :math:`\lambda_i`, :math:`u_i(t)` are
        eigenvalues / eigenfunctions of the following homogeneous Fredholm equation

        .. math:: \int_0^{t_\mathrm{max}} \mathrm{d}s R(t-s) u_i(s) = \lambda_i u_i(t)

        for a given positive integral kernel :math:`R(\tau)`. It turns out that the auto correlation of the
        stocastic processes :math:`\langle Z(t)Z^\ast(s) \rangle = R(t-s)` is given by that kernel.

        For the numeric implementation the integral equation will be discretized
        (see :py:func:`stocproc.method_kle.solve_hom_fredholm` for details) which leads to a regular matrix
        eigenvalue problem.
        The accuracy of the generated  process in terms of its auto correlation function depends on
        the quality of the eigenvalues and eigenfunction and thus of the number of discritization points.
        Further for a given threshold there is only a finite number of eigenvalues above that threshold,
        provided that the number of discritization points is large enough.

        Now the property of representing the integral kernel in terms of the eigenfunction

        .. math :: R(t-s) = \sum_i \lambda_i u_i(t) u_i^\ast(s)

        is used to find the number of discritization points and the number of used eigenfunctions such that
        the sum represents the kernel up to a given tolerance (see :py:func:`stocproc.method_kle.auto_ng`
        for details).
    """
    
    def __init__(self, r_tau, t_max, tol=1e-2, ng_fac=4, meth='fourpoint', diff_method='full', dm_random_samples=10**4,
        seed=None, align_eig_vec=False):
        """
        :param r_tau: the idesired auto correlation function of a single parameter tau
        :param t_max: specifies the time interval [0, t_max] for which the processes in generated
        :param tol: maximal deviation of the auto correlation function of the sampled processes from
            the given auto correlation r_tau.
        :param ngfac: specifies the fine grid to use for the spline interpolation, the intermediate points are
            calculated using integral interpolation
        :param meth: the method for calculation integration weights and times, a callable or one of the following strings
            'midpoint' ('midp'), 'trapezoidal' ('trapz'), 'simpson' ('simp'), 'fourpoint' ('fp'),
            'gauss_legendre' ('gl'), 'tanh_sinh' ('ts')
        :param diff_method: either 'full' or 'random', determines the points where the above success criterion is evaluated,
            'full': full grid in between the fine grid, such that the spline interpolation error is expected to be maximal
            'random': pick a fixed number of random times t and s within the interval [0, t_max]
        :param dm_random_samples: the number of random times used for diff_method 'random'
        :param seed: if not None seed the random number generator on init of this class with seed
        :param align_eig_vec: assures that :math:`re(u_i(0)) \leq 0` and :math:`im(u_i(0)) = 0` for all i

        .. note ::
           To circumvent the time consuming initializing the StocProc class can be saved and loaded using
           the standard python pickle module. The :py:func:`get_key` method may be used identify the
           Process class by its parameters (r_tau, t_max, tol).

        .. seealso ::
           Details on how to solve the homogeneous Fredholm equation: :py:func:`stocproc.method_kle.solve_hom_fredholm`

           Details on the error estimation and further clarification of the parameters ng_fac, meth,
           diff_method, dm_random_samples can be found at :py:func:`stocproc.method_kle.auto_ng`.
        """

        sqrt_lambda_ui_fine, t = method_kle.auto_ng(corr=r_tau,
                                                    t_max=t_max,
                                                    ngfac=ng_fac,
                                                    meth=meth,
                                                    tol=tol,
                                                    diff_method=diff_method,
                                                    dm_random_samples=dm_random_samples)

        # inplace alignment such that re(ui(0)) >= 0 and im(ui(0)) = 0
        if align_eig_vec:
            method_kle.align_eig_vec(sqrt_lambda_ui_fine)

        state = sqrt_lambda_ui_fine, t, seed
        self.__setstate__(state)
        self.key = r_tau, t_max, tol

    def get_key(self):
        """Returns the tuple (r_tau, t_max, tol) which should suffice to identify the process in order to load/dump
        the StocProc class.
        """
        return self.key

    def __getstate__(self):
        return self.sqrt_lambda_ui_fine, self.t, self._seed

    def __setstate__(self, state):
        sqrt_lambda_ui_fine, t, seed = state
        num_ev, ng = sqrt_lambda_ui_fine.shape
        super().__init__(t_axis=t, seed=seed)
        self.num_ev = num_ev
        self.sqrt_lambda_ui_fine = sqrt_lambda_ui_fine

    def calc_z(self, y):
        r"""evaluate :math:`z_k = \sum_i \lambda_i Y_i u_{ik}`"""
        return np.tensordot(y, self.sqrt_lambda_ui_fine, axes=([0], [0])).flatten()

    def get_num_y(self):
        """The number of independent random variables Y is given by the number of used eigenfunction
        to approximate the auto correlation kernel.
        """
        return self.num_ev


class StocProc_FFT(_absStocProc):
    r"""Simulate Stochastic Process using FFT method

    This method works only for auto correlations functions of the form

    .. math:: \alpha(\tau) = \int_{\omega_\mathrm{min}}^{\omega_\mathrm{max}} \mathrm{d}\omega \, \frac{J(\omega)}{\pi} e^{-\mathrm{i}\omega \tau}

    where :math:`J(\omega)` is a real non negative function, usually called spectral density.
    Then the integral can be approximated by a discrete integration schema:

    .. math:: \alpha(\tau) \approx \sum_{k=0}^{N-1} w_k \frac{J(\omega_k)}{\pi} e^{-\mathrm{i} k \omega_k \tau}

    where the :math:`\omega_k` depend on the integration schema.

    For a process defined by

    .. math:: Z(t) = \sum_{k=0}^{N-1} \sqrt{\frac{w_k J(\omega_k)}{\pi}} Y_k \exp^{-\mathrm{i}\omega_k t}

    with independent complex random variables :math:`Y_k` such that :math:`\langle Y_k \rangle = 0`,
    :math:`\langle Y_k Y_{k'}\rangle = 0` and :math:`\langle Y_k Y^\ast_{k'}\rangle = \Delta \omega \delta_{k,k'}`
    it is easy to see that its auto correlation function will be exactly the approximated auto correlation function.

    .. math::
        \begin{align}
            \langle Z(t) Z^\ast(s) \rangle = & \sum_{k,k'} \frac{1}{\pi} \sqrt{w_k w_{k'} J(\omega_k)J(\omega_{k'})} \langle Y_k Y_{k'}\rangle \exp(-\mathrm{i}(\omega_k t - \omega_k' s)) \\
                                           = & \sum_{k}    \frac{w_k}{\pi} J(\omega_k) e^{-\mathrm{i}\omega_k (t-s)} \\
                                           \approx & \alpha(t-s)
        \end{align}

    To calculate :math:`Z(t)` the schema of the Discrete Fourier Transform (DFT) can be applied as follows:

    .. math:: Z(t_l) = e^{-\mathrm{i}\omega_\mathrm{min} t_l} \sum_{k=0}^{N-1} \sqrt{\frac{w_k J(\omega_k)}{\pi}} Y_k  e^{-\mathrm{i} 2 \pi \frac{k l}{N} \frac{\Delta \omega \Delta t}{ 2 \pi} N}

    Here :math:`\omega_k` has to take the form :math:`\omega_k = \omega_\mathrm{min} + k \Delta \omega` and
    :math:`\Delta \omega = (\omega_\mathrm{max} - \omega_\mathrm{min}) / N-1` which limits
    the itegration schemas to those with equidistant weights.
    For the DFT schema to be applicable :math:`\Delta t` has to be chosen such that

    .. math:: 1 = \frac{\Delta \omega \Delta t}{2 \pi} N

    holds. Since :math:`J(\omega)` is real it follows that :math:`X(t_l) = X^\ast(t_{N-l})`.
    For that reason the stochastic process has only :math:`(N+1)/2` (odd :math:`N`) and
    :math:`(N/2 + 1)` (even :math:`N`) independent time grid points.

    .. math:: Z_l = e^{-\mathrm{i}\omega_\mathrm{min} t_l} DFT\left(\sqrt{w_k J(\omega_k) / \pi} \; Y_k\right) \qquad k = 0 \; ... \; N-1, \quad l = 0 \; ... \; n

    :param spectral_density: the spectral density :math:`J(\omega)` as callable function object
    :param t_max: :math:`[0,t_\mathrm{max}]` is the interval for which the process will be calculated
    :param num_grid_points: number :math:`n` of euqally distributed times :math:`t_k` on the intervall :math:`[0,t_\mathrm{max}]`
        for which the process will be evaluated
    :param num_samples: number of independent processes to be returned
    :param seed: seed passed to the random number generator used

    :return: returns the tuple (2D array of the set of stochastic processes,
        1D array of time grid points). Each row of the stochastic process
        array contains one sample of the stochastic process.

    """
    def __init__(self, spectral_density, t_max, bcf_ref, intgr_tol=1e-2, intpl_tol=1e-2,
                 seed=None, negative_frequencies=False):
        if not negative_frequencies: 
            log.info("non neg freq only")
            # assume the spectral_density is 0 for w<0 
            # and decays fast for large w
            b = method_fft.find_integral_boundary(integrand = spectral_density, 
                                                  tol       = intgr_tol**2,
                                                  ref_val   = 1, 
                                                  max_val   = 1e6, 
                                                  x0        = 1)
            log.info("upper int bound b {:.3e}".format(b))
            a, b, N, dx, dt = method_fft.calc_ab_N_dx_dt(integrand = spectral_density,
                                                         intgr_tol = intgr_tol,
                                                         intpl_tol = intpl_tol,
                                                         t_max     = t_max,
                                                         a         = 0,
                                                         b         = b,
                                                         ft_ref    = lambda tau:bcf_ref(tau)*np.pi,
                                                         opt_b_only= True,
                                                         N_max     = 2**24)
            log.info("required tol results in N {}".format(N))
        else:
            log.info("use neg freq")
            # assume the spectral_density is non zero also for w<0 
            # but decays fast for large |w|
            b = method_fft.find_integral_boundary(integrand = spectral_density, 
                                                  tol       = intgr_tol**2,
                                                  ref_val   = 1, 
                                                  max_val   = 1e6, 
                                                  x0        = 1)
            a = method_fft.find_integral_boundary(integrand = spectral_density, 
                                                  tol       = intgr_tol**2,
                                                  ref_val   = -1, 
                                                  max_val   = 1e6, 
                                                  x0        = -1)            
            a, b, N, dx, dt = method_fft.calc_ab_N_dx_dt(integrand = spectral_density,
                                                              intgr_tol = intgr_tol, 
                                                              intpl_tol = intpl_tol, 
                                                              t_max     = t_max,
                                                              a         = a,
                                                              b         = b,
                                                              ft_ref    = lambda tau:bcf_ref(tau)*np.pi,
                                                              opt_b_only= False,
                                                              N_max     = 2**24)
            log.info("required tol result in N {}".format(N))

        assert abs(2*np.pi - N*dx*dt) < 1e-12
        num_grid_points = int(np.ceil(t_max/dt))+1
        t_max = (num_grid_points-1)*dt
        
        super().__init__(t_max           = t_max, 
                         num_grid_points = num_grid_points, 
                         seed            = seed)
        
        omega = dx*np.arange(N)
        self.yl = spectral_density(omega + a + dx/2) * dx / np.pi
        self.yl = np.sqrt(self.yl)
        self.omega_min_correction = np.exp(-1j*(a+dx/2)*self.t)   #self.t is from the parent class
        self.key = bcf_ref, t_max, intgr_tol, intpl_tol

    def __getstate__(self):
        return self.yl, self.num_grid_points, self.omega_min_correction, self.t_max, self._seed

    def __setstate__(self, state):
        self.yl, num_grid_points, self.omega_min_correction, t_max, seed = state
        super().__init__(t_max           = t_max,
                         num_grid_points = num_grid_points,
                         seed            = seed)
            
    def calc_z(self, y):
        z = np.fft.fft(self.yl * y)[0:self.num_grid_points] * self.omega_min_correction
        return z

    def get_num_y(self):
        return len(self.yl)